{
    "sourceFile": "TestTP4.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1704353124622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1704353210325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,106 @@\n+import cv2\n+readimg = cv2.imread('fruit2.jpg')\n+maskSobelX = [[-1,0,1], [-2,0,2], [-1,0,1]]\n+maskSobelY = [[1,2,1], [0,0,0], [-1,-2,-1]]\n+\n+mOutImg = readimg.copy()\n+#extract height and width\n+h, w, ch = readimg.shape\n+print(w,h,ch)\n+#initailize 0\n+pTmpXB = (w*h)*[0]\n+pTmpXG = (w*h)*[0]\n+pTmpXR = (w*h)*[0]\n+pTmpYB = (w*h)*[0]\n+pTmpYG = (w*h)*[0]\n+pTmpYR = (w*h)*[0]\n+#initailize image to black or 0\n+mOutImg = mOutImg * 0\n+#apply mask to original image\n+for i in range(1,h-1):\n+    for j in range(1,w-1):\n+        newValueBx = 0\n+        newValueGx = 0\n+        newValueRx = 0\n+        newValueBy = 0\n+        newValueGy = 0\n+        newValueRy = 0\n+        # I1(i+k-1,j+l-1)*k(k,l) --> mc=k; mr=l\n+        for mr in range(3):\n+            for mc in range(3):\n+                # I1(i+k-1,j+l-1)\n+                r,g,b = readimg[i+mc-1,j+mr-1] \n+                # k(k,l) = maskSobelX[mr][mc]\n+                newValueBx += maskSobelX[mr][mc]*b\n+                newValueGx += maskSobelX[mr][mc]*g\n+                newValueRx += maskSobelX[mr][mc]*r\n+                newValueBy += maskSobelY[mr][mc]*b\n+                newValueGy += maskSobelY[mr][mc]*g\n+                newValueRy += maskSobelY[mr][mc]*r\n+        pTmpXB[i*w+j] = newValueBx\n+        pTmpXG[i*w+j] = newValueGx\n+        pTmpXR[i*w+j] = newValueRx\n+        pTmpYB[i*w+j] = newValueBy\n+        pTmpYG[i*w+j] = newValueGy\n+        pTmpYR[i*w+j] = newValueRy\n+#convert to positive\n+for i in range(1,h-1):\n+    for j in range(1,w-1):\n+        constBVal1,constGVal1,constRVal1=pTmpXB[i*w+j],pTmpXG[i*w+j],pTmpXR[i*w+j]\n+        constBVal2,constGVal2,constRVal2=pTmpYB[i*w+j],pTmpYG[i*w+j],pTmpYR[i*w+j]\n+        if constBVal1<0:\n+            constBVal1 = -constBVal1\n+        if constGVal1<0:\n+            constGVal1 = -constGVal1\n+        if constRVal1<0:\n+            constRVal1 = -constRVal1\n+        if constBVal2<0:\n+            constBVal2 = -constBVal2\n+        if constGVal2<0:\n+            constGVal2 = -constGVal2\n+        if constRVal2<0:\n+            constRVal2 = -constRVal2\n+        pTmpXB[i*w+j] = constBVal1+constBVal2\n+        pTmpXG[i*w+j] = constGVal1+constGVal2\n+        pTmpXR[i*w+j] = constRVal1+constRVal2\n+#new max and min of picture\n+minB=minG=minR=100000000\n+maxB=maxG=maxR=-100000000\n+for i in range(1,h-1):\n+    for j in range(1,w-1):\n+        newValueB=pTmpXB[i*w+j]\n+        newValueG=pTmpXG[i*w+j]\n+        newValueR=pTmpXR[i*w+j]\n+        if(newValueB<minB):\n+            minB = newValueB\n+        if(newValueB>maxB):\n+            maxB = newValueB\n+        if(newValueG<minG):\n+            minG = newValueG\n+        if(newValueG>maxG): \n+            maxG = newValueG\n+        if(newValueR<minR):\n+            minR = newValueR\n+        if(newValueR>maxR):\n+            maxR = newValueR\n+# normalize number --> can be range from 0 to 1 (original from 0 to 255)\n+constBVal1 = (float(255.0/(maxB-minB)))\n+constBVal2 = (float(-255.0*minB/(maxB-minB)))\n+constGVal1 = (float(255.0/(maxG-minG)))\n+constGVal2 = (float(-255.0*minG/(maxG-minG)))\n+constRVal1 = (float(255.0/(maxR-minR)))\n+constRVal2 = (float(-255.0 * minR/(maxR-minR)))\n+# apply new RGB\n+#for i in range(1,h-1):\n+  #for j in range(1,w-1):\n+        # Write your code here\n+\n+pTmpXB = []\n+pTmpXG = []\n+pTmpXR = []\n+pTmpYB = []\n+pTmpYG = []\n+pTmpYR = []\n+cv2.imshow(\"Sobel Edge Detection\",mOutImg)\n+cv2.imshow(\"Origin\",readimg)\n+cv2.waitKey()\n"
                },
                {
                    "date": 1704353316529,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,117 +90,12 @@\n constGVal2 = (float(-255.0*minG/(maxG-minG)))\n constRVal1 = (float(255.0/(maxR-minR)))\n constRVal2 = (float(-255.0 * minR/(maxR-minR)))\n # apply new RGB\n-#for i in range(1,h-1):\n-  #for j in range(1,w-1):\n-        # Write your code here\n-\n-pTmpXB = []\n-pTmpXG = []\n-pTmpXR = []\n-pTmpYB = []\n-pTmpYG = []\n-pTmpYR = []\n-cv2.imshow(\"Sobel Edge Detection\",mOutImg)\n-cv2.imshow(\"Origin\",readimg)\n-cv2.waitKey()\n-import cv2\n-readimg = cv2.imread('fruit2.jpg')\n-maskSobelX = [[-1,0,1], [-2,0,2], [-1,0,1]]\n-maskSobelY = [[1,2,1], [0,0,0], [-1,-2,-1]]\n-\n-mOutImg = readimg.copy()\n-#extract height and width\n-h, w, ch = readimg.shape\n-print(w,h,ch)\n-#initailize 0\n-pTmpXB = (w*h)*[0]\n-pTmpXG = (w*h)*[0]\n-pTmpXR = (w*h)*[0]\n-pTmpYB = (w*h)*[0]\n-pTmpYG = (w*h)*[0]\n-pTmpYR = (w*h)*[0]\n-#initailize image to black or 0\n-mOutImg = mOutImg * 0\n-#apply mask to original image\n for i in range(1,h-1):\n-    for j in range(1,w-1):\n-        newValueBx = 0\n-        newValueGx = 0\n-        newValueRx = 0\n-        newValueBy = 0\n-        newValueGy = 0\n-        newValueRy = 0\n-        # I1(i+k-1,j+l-1)*k(k,l) --> mc=k; mr=l\n-        for mr in range(3):\n-            for mc in range(3):\n-                # I1(i+k-1,j+l-1)\n-                r,g,b = readimg[i+mc-1,j+mr-1] \n-                # k(k,l) = maskSobelX[mr][mc]\n-                newValueBx += maskSobelX[mr][mc]*b\n-                newValueGx += maskSobelX[mr][mc]*g\n-                newValueRx += maskSobelX[mr][mc]*r\n-                newValueBy += maskSobelY[mr][mc]*b\n-                newValueGy += maskSobelY[mr][mc]*g\n-                newValueRy += maskSobelY[mr][mc]*r\n-        pTmpXB[i*w+j] = newValueBx\n-        pTmpXG[i*w+j] = newValueGx\n-        pTmpXR[i*w+j] = newValueRx\n-        pTmpYB[i*w+j] = newValueBy\n-        pTmpYG[i*w+j] = newValueGy\n-        pTmpYR[i*w+j] = newValueRy\n-#convert to positive\n-for i in range(1,h-1):\n-    for j in range(1,w-1):\n-        constBVal1,constGVal1,constRVal1=pTmpXB[i*w+j],pTmpXG[i*w+j],pTmpXR[i*w+j]\n-        constBVal2,constGVal2,constRVal2=pTmpYB[i*w+j],pTmpYG[i*w+j],pTmpYR[i*w+j]\n-        if constBVal1<0:\n-            constBVal1 = -constBVal1\n-        if constGVal1<0:\n-            constGVal1 = -constGVal1\n-        if constRVal1<0:\n-            constRVal1 = -constRVal1\n-        if constBVal2<0:\n-            constBVal2 = -constBVal2\n-        if constGVal2<0:\n-            constGVal2 = -constGVal2\n-        if constRVal2<0:\n-            constRVal2 = -constRVal2\n-        pTmpXB[i*w+j] = constBVal1+constBVal2\n-        pTmpXG[i*w+j] = constGVal1+constGVal2\n-        pTmpXR[i*w+j] = constRVal1+constRVal2\n-#new max and min of picture\n-minB=minG=minR=100000000\n-maxB=maxG=maxR=-100000000\n-for i in range(1,h-1):\n-    for j in range(1,w-1):\n-        newValueB=pTmpXB[i*w+j]\n-        newValueG=pTmpXG[i*w+j]\n-        newValueR=pTmpXR[i*w+j]\n-        if(newValueB<minB):\n-            minB = newValueB\n-        if(newValueB>maxB):\n-            maxB = newValueB\n-        if(newValueG<minG):\n-            minG = newValueG\n-        if(newValueG>maxG): \n-            maxG = newValueG\n-        if(newValueR<minR):\n-            minR = newValueR\n-        if(newValueR>maxR):\n-            maxR = newValueR\n-# normalize number --> can be range from 0 to 1 (original from 0 to 255)\n-constBVal1 = (float(255.0/(maxB-minB)))\n-constBVal2 = (float(-255.0*minB/(maxB-minB)))\n-constGVal1 = (float(255.0/(maxG-minG)))\n-constGVal2 = (float(-255.0*minG/(maxG-minG)))\n-constRVal1 = (float(255.0/(maxR-minR)))\n-constRVal2 = (float(-255.0 * minR/(maxR-minR)))\n-# apply new RGB\n-#for i in range(1,h-1):\n-#    for j in range(1,w-1):\n+  for j in range(1,w-1):\n         # Write your code here\n+        newValueB = pTmpXB[i * w  + j]  \n \n pTmpXB = []\n pTmpXG = []\n pTmpXR = []\n"
                }
            ],
            "date": 1704353124622,
            "name": "Commit-0",
            "content": "import cv2\nreadimg = cv2.imread('fruit2.jpg')\nmaskSobelX = [[-1,0,1], [-2,0,2], [-1,0,1]]\nmaskSobelY = [[1,2,1], [0,0,0], [-1,-2,-1]]\n\nmOutImg = readimg.copy()\n#extract height and width\nh, w, ch = readimg.shape\nprint(w,h,ch)\n#initailize 0\npTmpXB = (w*h)*[0]\npTmpXG = (w*h)*[0]\npTmpXR = (w*h)*[0]\npTmpYB = (w*h)*[0]\npTmpYG = (w*h)*[0]\npTmpYR = (w*h)*[0]\n#initailize image to black or 0\nmOutImg = mOutImg * 0\n#apply mask to original image\nfor i in range(1,h-1):\n    for j in range(1,w-1):\n        newValueBx = 0\n        newValueGx = 0\n        newValueRx = 0\n        newValueBy = 0\n        newValueGy = 0\n        newValueRy = 0\n        # I1(i+k-1,j+l-1)*k(k,l) --> mc=k; mr=l\n        for mr in range(3):\n            for mc in range(3):\n                # I1(i+k-1,j+l-1)\n                r,g,b = readimg[i+mc-1,j+mr-1] \n                # k(k,l) = maskSobelX[mr][mc]\n                newValueBx += maskSobelX[mr][mc]*b\n                newValueGx += maskSobelX[mr][mc]*g\n                newValueRx += maskSobelX[mr][mc]*r\n                newValueBy += maskSobelY[mr][mc]*b\n                newValueGy += maskSobelY[mr][mc]*g\n                newValueRy += maskSobelY[mr][mc]*r\n        pTmpXB[i*w+j] = newValueBx\n        pTmpXG[i*w+j] = newValueGx\n        pTmpXR[i*w+j] = newValueRx\n        pTmpYB[i*w+j] = newValueBy\n        pTmpYG[i*w+j] = newValueGy\n        pTmpYR[i*w+j] = newValueRy\n#convert to positive\nfor i in range(1,h-1):\n    for j in range(1,w-1):\n        constBVal1,constGVal1,constRVal1=pTmpXB[i*w+j],pTmpXG[i*w+j],pTmpXR[i*w+j]\n        constBVal2,constGVal2,constRVal2=pTmpYB[i*w+j],pTmpYG[i*w+j],pTmpYR[i*w+j]\n        if constBVal1<0:\n            constBVal1 = -constBVal1\n        if constGVal1<0:\n            constGVal1 = -constGVal1\n        if constRVal1<0:\n            constRVal1 = -constRVal1\n        if constBVal2<0:\n            constBVal2 = -constBVal2\n        if constGVal2<0:\n            constGVal2 = -constGVal2\n        if constRVal2<0:\n            constRVal2 = -constRVal2\n        pTmpXB[i*w+j] = constBVal1+constBVal2\n        pTmpXG[i*w+j] = constGVal1+constGVal2\n        pTmpXR[i*w+j] = constRVal1+constRVal2\n#new max and min of picture\nminB=minG=minR=100000000\nmaxB=maxG=maxR=-100000000\nfor i in range(1,h-1):\n    for j in range(1,w-1):\n        newValueB=pTmpXB[i*w+j]\n        newValueG=pTmpXG[i*w+j]\n        newValueR=pTmpXR[i*w+j]\n        if(newValueB<minB):\n            minB = newValueB\n        if(newValueB>maxB):\n            maxB = newValueB\n        if(newValueG<minG):\n            minG = newValueG\n        if(newValueG>maxG): \n            maxG = newValueG\n        if(newValueR<minR):\n            minR = newValueR\n        if(newValueR>maxR):\n            maxR = newValueR\n# normalize number --> can be range from 0 to 1 (original from 0 to 255)\nconstBVal1 = (float(255.0/(maxB-minB)))\nconstBVal2 = (float(-255.0*minB/(maxB-minB)))\nconstGVal1 = (float(255.0/(maxG-minG)))\nconstGVal2 = (float(-255.0*minG/(maxG-minG)))\nconstRVal1 = (float(255.0/(maxR-minR)))\nconstRVal2 = (float(-255.0 * minR/(maxR-minR)))\n# apply new RGB\n#for i in range(1,h-1):\n#    for j in range(1,w-1):\n        # Write your code here\n\npTmpXB = []\npTmpXG = []\npTmpXR = []\npTmpYB = []\npTmpYG = []\npTmpYR = []\ncv2.imshow(\"Sobel Edge Detection\",mOutImg)\ncv2.imshow(\"Origin\",readimg)\ncv2.waitKey()\n"
        }
    ]
}